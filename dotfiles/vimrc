vim9script

# Plugins ---------------------------------------------------------- {{{
const RepoPrefix = 'https://github.com/'
const PackageRoot = expand('~/.vim/pack/plugins')
const StartDir = PackageRoot .. '/start'
const PluginRepos = [
\   'rust-lang/rust.vim',
\   'cespare/vim-toml',
\   'ziglang/zig.vim',
\   'jiangmiao/auto-pairs',
\   'enkron/ecs_light.vim',
\   'enkron/ecs.vim',
\   'tpope/vim-obsession.git',
\   'sheerun/vim-polyglot',
\   'dense-analysis/ale',
\   'prabirshrestha/async.vim',
\   'prabirshrestha/vim-lsp',
\   'prabirshrestha/vim-lsp-settings',
\]
# Add plugins by appending 'owner/repo' to s:PluginRepos above.
# Run :PluginsUpdate to clone or refresh every plugin via git.

def PluginName(repo: string): string
    const parts = split(repo, '/')
    var name = parts[len(parts) - 1]
    if name =~ '\.git$'
        name = substitute(name, '\.git$', '', '')
    endif
    return name
enddef

def PluginPath(repo: string): string
    return StartDir .. '/' .. PluginName(repo)
enddef

def EnsureStartDir()
    if !isdirectory(StartDir)
        mkdir(StartDir, 'p')
    endif
enddef

def g:RunOrThrow(cmd: any)
    var command = ''
    if type(cmd) == v:t_list
        var parts = copy(cmd)
        for idx in range(len(parts))
            parts[idx] = shellescape(parts[idx])
        endfor
        command = join(parts, ' ')
    else
        command = cmd
    endif
    var output = system(command)
    if v:shell_error != 0
        throw printf('Command failed (%d): %s%s%s',
            v:shell_error,
            type(cmd) == v:t_list ? string(cmd) : command,
            empty(output) ? '' : "\n",
            empty(output) ? '' : output)
    endif
enddef

def SyncPlugin(repo: string)
    EnsureStartDir()
    const target = PluginPath(repo)
    if isdirectory(target .. '/.git')
        g:RunOrThrow(['git', '-C', target, 'pull', '--ff-only'])
    else
        g:RunOrThrow(['git', 'clone', '--depth', '1', RepoPrefix .. repo, target])
    endif
enddef

def PluginsUpdate()
    if !executable('git')
        echohl ErrorMsg
        echom 'git executable not found; cannot install plugins.'
        echohl None
        return
    endif
    try
        for repo in PluginRepos
            SyncPlugin(repo)
        endfor
        packloadall
        echom 'Plugins updated.'
    catch
        echohl ErrorMsg
        echom v:exception
        echohl None
    endtry
enddef

command! PluginsUpdate call PluginsUpdate()

# Disable some languages inside vim-polyglot (must be done before loading it)
g:polyglot_disabled = ['zig', 'rust']
# Keep vim-lsp-settings installed for optional helpers but suppress its auto
# registrations/suggestions since servers below handle everything.
g:lsp_settings_whitelist = []
# }}}

# General settings ------------------------------------------------- {{{
if &term != "linux"
    set t_Co=256
    silent! colorscheme ecs
endif

set term=${TERM}

syntax on                            # enable syntax highlighting
set nocompatible                     # enables to use Vim specific features
filetype off                         # reset filetype detection first ...
filetype plugin indent on            # ... and enable filetype detection
set omnifunc=syntaxcomplete#Complete
set tabstop=4                        # set tabs to have 4 spaces
set shiftwidth=4                     # when using the >> or << commands,
                                     # shift lines by 4 spaces
set expandtab                        # expand tabs into spaces
set smarttab
set smartindent
set number                           # show line numbers
set relativenumber                   # each line in a file is numbered relative
                                     # to the cursor’s current position to show
                                     # the distance to that line
set showmatch                        # show the matching part
                                     # of the pair for [] {} and ()
set cursorline                       # show a visual line under the cursor's current line

if v:version >= 801                  # `v: name` - variable predefined by Vim
    set cursorlineopt=number,screenline  # settings for how 'cursorline' is displayed
endif

set fileformat=unix                  # store the file in a Unix format
set textwidth=99                     # set global width default
augroup MarkdownTextWidth
    autocmd!
    autocmd FileType markdown setlocal textwidth=79 # specific width for markdown
augroup END
set encoding=utf-8                   # set default encoding used inside Vim
set ruler                            # show the cursor position all the time
set history=50                       # keep 50 lines of command line history
set viminfo='20,\"50                 # read/write a .viminfo file, don't store more
                                     # than 50 lines of registers
set bs=indent,eol,start              # allow backspacing over everything in insert mode
set noswapfile                       # don't use swapfile
set nobackup                         # don't create backup files
set showcmd                          # show what i'm typing
set hlsearch                         # enable highlight searched patterns
set hidden                           # turn on 'hidden' mode for buffers
#set nowrap                          " do not wrap lines
                                     # allow long lines to extend as far as the line goes
set incsearch                        # while searching though a file incrementally
                                     # highlight matching characters as you type
# set ignorecase                     " ignore capital letters during search
# set smartcase                      " override the ignorecase option if searching for capital letters
                                     # this will allow to search specifically for capital letters
set showmode                         # show the mode you are on the last line.
set completeopt=menu,menuone,popup,noselect,noinsert # autocomplete with popup windows
set wildoptions=pum                  # Popup menu completion
# }}}

# Statusline ------------------------------------------------------- {{{
set laststatus=2                        # show the status on the second to last line
set statusline=                         # clear status line when vimrc is reloaded
set statusline+=%1*\%{&ff}%y\ %*
set statusline+=%2*\»\ %*
set statusline+=%3*\%n%m\%*
set statusline+=%1*\:%t\ %*
set statusline+=%=
set statusline+=%5*\%4l%*
set statusline+=%6*/%*
set statusline+=%1*\%L%*
set statusline+=%2*\ «\ %*
set statusline+=%4*\0x%B\%*
set statusline+=%6*/%*
set statusline+=%5*%c\%*
# set statusline=%<%F%=\ [%1*%M%*%n%R%H]\ %-19(%3l.%02c%03V%)%-6(%p%%%)%O'%02b'
# }}}

# Vim scripts ------------------------------------------------------ {{{
# allow to fold long files to hide sections of text
# by default `marker` is mapped to '{{{ }}}' chars
# for example: " FOLDING SECTION --- {{{ a section code goes here }}}
# zo - opens a single fold under the cursor.
# zc - closes the fold under the cursor.
# zR - opens all folds.
# zM - closes all folds.
augroup filetype_vim
    autocmd!
    autocmd FileType vim setlocal foldmethod=marker
augroup END

# Override conceal level which could be set by some plugin
autocmd BufEnter * set conceallevel=0
# }}}

# Vim functions ---------------------------------------------------- {{{
# Below function allows to avoid entering the `INSERT` mode while splitting a
# long line (Vim doesn't have this type of method by default)
def g:SplitLine()
    s/^\(\s*\)\(.\{-}\)\(\s*\)\(\%#\)\(\s*\)\(.*\)/\1\2\r\1\4\6
    histdel('/', -1)
enddef

def g:ScrollPopup(nlines: number)
    var winids = popup_list()
    if len(winids) == 0
        return
    endif

    var prop = popup_getpos(winids[0])
    if prop.visible != 1
        return
    endif

    var firstline = prop.firstline + nlines
    var buf_lastline = str2nr(trim(win_execute(winids[0], "echo line('$')")))
    if firstline < 1
        firstline = 1
    elseif prop.lastline + nlines > buf_lastline
        firstline = buf_lastline + prop.firstline - prop.lastline
    endif

    popup_setoptions(winids[0], {'firstline': firstline})
enddef
# }}}

# Plugins settings ------------------------------------------------- {{{
# rust.vim
g:rustfmt_autosave = 1
g:rust_keep_autopairs_default = 0
g:rust_fold = 1

# asm.vim
# set filetype=nasm
# let g:asmsyntax = 'nasm'

# ALE (Asynchronous Lint Engine) ---------------------------------- {{{
# ALE is used *only* for linting. Actual LSP features (completion,
# go-to-definition, rename, references, etc.) come from vim-lsp.

g:ale_disable_lsp = 1                # Prevent ALE from acting as an LSP client
g:ale_completion_enabled = 0         # Disable ALE completion (vim-lsp handles it)
g:ale_hover_to_floating_preview = 1  # Keep ALE's hover popup (non-LSP)
g:ale_fix_on_save = 1                # Auto-fix when saving
g:ale_rust_cargo_use_clippy = executable('cargo-clippy')

g:ale_linters = {
\   'rust':   ['cargo'],
\   'python': ['ruff', 'mypy']
\}

g:ale_fixers = {
\   '*': ['remove_trailing_lines', 'trim_whitespace']
\}
# }}}

# vim-lsp configuration -------------------------------------------- {{{
# Enable LSP popups with better default UI
g:lsp_diagnostics_enabled = 1
g:lsp_document_highlight_enabled = 1
g:lsp_hover_ui = 'float'
g:lsp_log_verbose = 0
g:lsp_log_file = expand('~/.vim-lsp.log')

# Auto-completion support using built-in Vim popup menu
# (vim-lsp provides the actual LSP completion items)
set completeopt=menu,menuone,popup,noselect,noinsert

g:zls_install_root = get(g:, 'zls_install_root', expand('~/.local/share/zls'))

def LspProjectRoot(markers: list<string>): string
    var path = lsp#utils#find_nearest_parent_file_directory(expand('%:p'), markers)
    return empty(path) ? getcwd() : path
enddef

def LspRootUri(markers: list<string>, _server_info: dict<any>): string
    return lsp#utils#path_to_uri(LspProjectRoot(markers))
enddef

def g:ZlsRepoDir(): string
    return fnamemodify(g:zls_install_root, ':p')
enddef

def g:ZlsBinaryPath(): string
    return g:ZlsRepoDir() .. '/zig-out/bin/zls'
enddef

def g:ZlsCmd(): list<string>
    if executable('zls')
        return ['zls']
    endif
    const path = g:ZlsBinaryPath()
    if filereadable(path) && executable(path)
        return [path]
    endif
    return []
enddef

var zls_missing_warning = 0

def g:RegisterZls()
    const cmd = g:ZlsCmd()
    if empty(cmd)
        zls_missing_warning = 1
        if &filetype ==# 'zig'
            WarnMissingZls()
        endif
        return
    endif
    lsp#register_server({
    \   'name': 'zls',
    \   'cmd': cmd,
    \   'root_uri': function('LspRootUri', [['build.zig', '.git/']]),
    \   'allowlist': ['zig'],
    \ })
enddef

def WarnMissingZls()
    if zls_missing_warning
        echohl WarningMsg
        echom 'ZLS not found; run :ZlsInstall to build it or install it via your package manager.'
        echohl None
        zls_missing_warning = 0
    endif
enddef

def TerraformLsCmd(): list<string>
    if executable('terraform-ls')
        return ['terraform-ls', 'serve']
    endif
    return []
enddef

var terraform_ls_missing_warning = 0

def g:RegisterTerraformLs()
    const cmd = TerraformLsCmd()
    if empty(cmd)
        terraform_ls_missing_warning = 1
        if index(['terraform', 'terraform-vars'], &filetype) >= 0
            WarnMissingTerraformLs()
        endif
        return
    endif
    lsp#register_server({
    \   'name': 'terraform-ls',
    \   'cmd': cmd,
    \   'root_uri': function('LspRootUri', [['main.tf', 'versions.tf', 'providers.tf', '.terraform/', '.git/']]),
    \   'allowlist': ['terraform', 'terraform-vars'],
    \ })
enddef

def WarnMissingTerraformLs()
    if terraform_ls_missing_warning
        echohl WarningMsg
        echom 'terraform-ls not found; install the official terraform-ls binary and ensure it is available in $PATH.'
        echohl None
        terraform_ls_missing_warning = 0
    endif
enddef

def g:RegisterRustAnalyzer()
    if !executable('rust-analyzer')
        return
    endif
    lsp#register_server({
    \   'name': 'rust-analyzer',
    \   'cmd': ['rust-analyzer'],
    \   'root_uri': function('LspRootUri', [['Cargo.toml', '.git/']]),
    \   'allowlist': ['rust'],
    \ })
enddef

def g:RegisterPylsp()
    if !executable('pylsp')
        return
    endif
    lsp#register_server({
    \   'name': 'pylsp',
    \   'cmd': ['pylsp'],
    \   'root_uri': function('LspRootUri', [['pyproject.toml', 'setup.cfg', 'requirements.txt', '.git/']]),
    \   'allowlist': ['python'],
    \ })
enddef

def g:RegisterAllLspServers()
    g:RegisterZls()
    g:RegisterTerraformLs()
    g:RegisterRustAnalyzer()
    g:RegisterPylsp()
enddef

augroup custom_lsp_servers
    autocmd!
    autocmd User lsp_setup call g:RegisterAllLspServers()
    autocmd User lsp_buffer_enabled setlocal omnifunc=lsp#complete
    autocmd FileType zig call WarnMissingZls()
    autocmd FileType terraform,terraform-vars call WarnMissingTerraformLs()
augroup END

def g:ZlsInstall()
    if !executable('git')
        echohl ErrorMsg | echom 'Cannot install ZLS: git is required.' | echohl None
        return
    endif
    if !executable('zig')
        echohl ErrorMsg | echom 'Cannot install ZLS: zig compiler is required.' | echohl None
        return
    endif
    var repo = g:ZlsRepoDir()
    var parent = fnamemodify(repo, ':h')
    if !isdirectory(parent)
        mkdir(parent, 'p')
    endif
    try
        if !isdirectory(repo .. '/.git')
            if isdirectory(repo)
                throw printf('Cannot install ZLS: %s exists but is not a git repository.', repo)
            endif
            g:RunOrThrow(['git', 'clone', '--depth', '1', 'https://github.com/zigtools/zls', repo])
        else
            g:RunOrThrow(['git', '-C', repo, 'pull', '--ff-only'])
        endif
        const build = printf('cd %s && zig build -Doptimize=ReleaseSafe', shellescape(repo))
        g:RunOrThrow(['sh', '-c', build])
    catch
        echohl ErrorMsg | echom v:exception | echohl None
        return
    endtry
    const cmd = g:ZlsCmd()
    if empty(cmd)
        echohl ErrorMsg | echom 'ZLS build finished but no executable was found under ' . g:ZlsRepoDir() | echohl None
    else
        echom 'ZLS installed at ' . cmd[0]
    endif
enddef

command! ZlsInstall call g:ZlsInstall()

# LSP reference highlighting
# Trigger highlight after 300ms instead of Vim’s default 4s
set updatetime=300

# Highlight color (vim-lsp uses lowercase `lspReference`)
highlight LspReferenceText  cterm=bold ctermbg=88 guibg=#96653a
highlight LspReferenceRead  cterm=bold ctermbg=88 guibg=#96653a
highlight LspReferenceWrite cterm=bold ctermbg=88 guibg=#96653a
highlight! link lspReference LspReferenceText

# Automatically clear highlights when cursor moves
augroup LspReferenceHighlight
    autocmd!
    autocmd CursorMoved  * silent! call lsp#ui#vim#clear_references()
    autocmd CursorMovedI * silent! call lsp#ui#vim#clear_references()
augroup END
# }}}

# }}}

# Key mappings ----------------------------------------------------- {{{
# nnoremap – allows to map keys in normal mode
# inoremap – allows to map keys in insert mode
# vnoremap – allows to map keys in visual mode
g:mapleader = ' ' # by default mapleader variable is set to '\'

# the more often save action occurs, the more likely the data won't be
# lost
# nnoremap <Space> :w!<CR>
cnoremap W<CR> :w!<CR>

# switch between buffers
nnoremap <leader>b :ls<CR>:buffer<Space>
# switch between last buffers
nnoremap <leader>ll :b#<CR>

# ugly change pattern
nnoremap <leader>c :%s///g<Left><Left><Left>
# replace all occurences of a particular word under the cursor
nnoremap <leader>co :%s/\<<C-r>=expand('<cword>')<CR>\>//g<Left><Left>
# replace all occurences of a word on a current row only
nnoremap <leader>cl :.s/\<<C-r>=expand('<cword>')<CR>\>//g<Left><Left>
# count number of matches of a pattern
nnoremap <leader>gn :%s/\<<C-r>=expand('<cword>')<CR>\>//gn<CR>

# release search highlighting
nnoremap <leader><space> :nohlsearch<CR>

# switch between bracets pairs (actual for mac keyboard)
nnoremap ~ %

# on/off trailing whitespaces visibility
nnoremap <leader>l :set list listchars=tab:>-,trail:∙,eol:¶<CR>
nnoremap <leader>nl :set nolist<CR>

# obtain highlighting information under the coursor
nnoremap <leader>hi :execute 'hi' synIDattr(synID(line("."), col("."), 1), "name")<CR>

# change behaviour of the `o` and `O` keys: by default these keys enters
# into the INSERT mode immediately after a call, below binding leaves it
# in COMMAND mode
map o o<ESC>
map <S-o> <S-o><ESC>

# format all long lines in a file without affecting short lines
# tw (textwidth) option could be set for a new formatting option
# check existing tw -> :setl tw?
# reset current tw to defaults -> :setl tw&
nmap <leader>f :g/./ normal gqq<CR><ESC> :nohlsearch<CR>``

# most of the Linux terminals sends the escape by default when pressing
# alt/meta+normal_mode_key
imap <M-h> <ESC>

# map Left to Ctrl+b in cmd mode to have behaviour like in terminal
cnoremap <C-b> <Left>
# map Right to Ctrl+f in cmd mode to have behaviour like in terminal
cnoremap <C-f> <Right>
# map Home to Ctrl+a in cmd mode to have behaviour like in terminal
cnoremap <C-a> <Home>

# inoremap () ()<Left>
# inoremap [] []<Left>
# inoremap {} {}<Left>
# inoremap "" ""<Left>
# inoremap ' ''<Left>
# inoremap ` ``<Left>

# search mappings: these will make it so that going to the
# next one in a search will center on the line it's found in.
nnoremap n nzzzv
nnoremap N Nzzzv

# when long lines inserted j k moves one physical line
# gj gk moves down one displayed line
noremap <Up> gk
noremap <Down> gj
noremap j gj
noremap k gk

# maybe later i'll figure out for what this mode is needed..
nnoremap Q <NOP>
# do not show q: window
# upd(24-Mar-22): understood at last: q: - shows the history of last
# commands, also 'q:' suffix works within gq+(line_num/G) command
# eg. `gq3<CR>` - formats next 3 lines according to the `tw` value
# nnoremap q: <NOP>

# reload vim configuration file
# nnoremap <leader>rc :source<space>~/.vimrc<CR>

# split long lines in `NORMAL` mode
nnoremap <leader>sl :<C-u>call SplitLine()<CR>

# add a `?` to the end of the line,
# return the cursor to its original spot.
inoremap ?? <C-o>mp<C-o>A?<C-o>`p

# sync syntax highlighting (sometimes vim gets confused in a long file)
nnoremap <leader>ss :syntax sync fromstart<CR>

# popup window scrolling
nnoremap <buffer> <C-n> <Cmd>call g:ScrollPopup(3)<CR>
nnoremap <buffer> <C-p> <Cmd>call g:ScrollPopup(-3)<CR>

# Reload undo history
nmap <leader>ee :setl undoreload=0 \|edit<CR>

# Source ~/.vimrc
nmap <leader>rc :source $MYVIMRC<CR>:nohlsearch<CR>

# LSP key mappings ------------------------------------------------ {{{
# Basic IDE-style navigation using vim-lsp

# Go to definition
nnoremap <leader>gt :LspDefinition<CR>
# Find references
nnoremap <leader>gr :LspReferences<CR>
# Go to implementation
nnoremap <leader>gi :LspImplementation<CR>
# Rename symbol
nnoremap <leader>rn :LspRename<CR>
# Show documentation
nnoremap <leader>p  :LspHover<CR>
# Symbols in file
nnoremap <leader>fs :LspDocumentSymbol<CR>
# Workspace symbols
nnoremap <leader>ws :LspWorkspaceSymbol<CR>
# Code actions (fix, refactor)
nnoremap <leader>ca :LspCodeAction<CR>
# Go to declaration
nnoremap <leader>gd :LspDeclaration<CR>
# Next error
nnoremap <leader>e  :LspNextDiagnostic<CR>
# Previous error
nnoremap <leader>E  :LspPreviousDiagnostic<CR>
# }}}

# }}}
